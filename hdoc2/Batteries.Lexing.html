<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="Batteries.Int64.html">
<link rel="next" href="Batteries.List.html">
<link rel="Up" href="Batteries.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatBytesCompat" rel="Chapter" href="BatBytesCompat.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcreteQueue" rel="Chapter" href="BatConcreteQueue.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFilename" rel="Chapter" href="BatFilename.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerShuffle" rel="Chapter" href="BatInnerShuffle.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOpaqueInnerSys" rel="Chapter" href="BatOpaqueInnerSys.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Positions" rel="Section" href="#6_Positions">
<link title="Lexer buffers" rel="Section" href="#6_Lexerbuffers">
<link title="Functions for lexer semantic actions" rel="Section" href="#6_Functionsforlexersemanticactions">
<link title="Miscellaneous functions" rel="Section" href="#6_Miscellaneousfunctions">
<title>Batteries user guide : Batteries.Lexing</title>
</head>
<body>
<div class="navbar"><a class="pre" href="Batteries.Int64.html" title="Batteries.Int64">Previous</a>
&nbsp;<a class="up" href="Batteries.html" title="Batteries">Up</a>
&nbsp;<a class="post" href="Batteries.List.html" title="Batteries.List">Next</a>
</div>
<h1>Module <a href="type_Batteries.Lexing.html">Batteries.Lexing</a></h1>

<pre><span id="MODULELexing"><span class="keyword">module</span> Lexing</span>: <code class="type"><a href="BatLexing.html">BatLexing</a></code></pre><hr width="100%">
<p>The run-time library for lexers generated by <code class="code">ocamllex</code>.</p>
<h7 id="6_Positions">Positions</h7>
<pre><span id="TYPEposition"><span class="keyword">type</span> <code class="type"></code>position</span> = <code class="type">Stdlib.Lexing.position</code> = {</pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTposition.pos_fname">pos_fname</span>&nbsp;: <code class="type">string</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTposition.pos_lnum">pos_lnum</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTposition.pos_bol">pos_bol</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTposition.pos_cnum">pos_cnum</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>A value of type <code class="code">position</code> describes a point in a source file.
    <code class="code">pos_fname</code> is the file name; <code class="code">pos_lnum</code> is the line number;
    <code class="code">pos_bol</code> is the offset of the beginning of the line (number
    of characters between the beginning of the file and the beginning
    of the line); <code class="code">pos_cnum</code> is the offset of the position (number of
    characters between the beginning of the file and the position).</p>

<p>See the documentation of type <code class="code">lexbuf</code> for information about
    how the lexing engine will manage positions.</p>
</div>
</div>


<pre><span id="VALdummy_pos"><span class="keyword">val</span> dummy_pos</span> : <code class="type"><a href="BatLexing.html#TYPEposition">position</a></code></pre><div class="info ">
<div class="info-desc">
<p>A value of type <code class="code">position</code>, guaranteed to be different from any
    valid position.</p>
</div>
</div>
<h7 id="6_Lexerbuffers">Lexer buffers</h7>
<pre><span id="TYPElexbuf"><span class="keyword">type</span> <code class="type"></code>lexbuf</span> = <code class="type">Stdlib.Lexing.lexbuf</code> = {</pre><table class="typetable">
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span id="TYPEELTlexbuf.refill_buff">refill_buff</span>&nbsp;: <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> unit</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_buffer">lex_buffer</span>&nbsp;: <code class="type">Stdlib.Bytes.t</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_buffer_len">lex_buffer_len</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_abs_pos">lex_abs_pos</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_start_pos">lex_start_pos</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_curr_pos">lex_curr_pos</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_last_pos">lex_last_pos</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_last_action">lex_last_action</span>&nbsp;: <code class="type">int</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_eof_reached">lex_eof_reached</span>&nbsp;: <code class="type">bool</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_mem">lex_mem</span>&nbsp;: <code class="type">int array</code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_start_p">lex_start_p</span>&nbsp;: <code class="type"><a href="BatLexing.html#TYPEposition">position</a></code>;</code></td>

</tr>
<tr>
<td align="left" valign="top" >
<code>&nbsp;&nbsp;</code></td>
<td align="left" valign="top" >
<code><span class="keyword">mutable&nbsp;</span><span id="TYPEELTlexbuf.lex_curr_p">lex_curr_p</span>&nbsp;: <code class="type"><a href="BatLexing.html#TYPEposition">position</a></code>;</code></td>

</tr></table>
}

<div class="info ">
<div class="info-desc">
<p>The type of lexer buffers. A lexer buffer is the argument passed
    to the scanning functions defined by the generated scanners.
    The lexer buffer holds the current state of the scanner, plus
    a function to refill the buffer from the input.</p>

<p>At each token, the lexing engine will copy <code class="code">lex_curr_p</code> to
    <code class="code">lex_start_p</code>, then change the <code class="code">pos_cnum</code> field
    of <code class="code">lex_curr_p</code> by updating it with the number of characters read
    since the start of the <code class="code">lexbuf</code>.  The other fields are left
    unchanged by the lexing engine.  In order to keep them
    accurate, they must be initialised before the first use of the
    lexbuf, and updated by the relevant lexer actions (i.e. at each
    end of line -- see also <code class="code">new_line</code>).</p>

<p>Note: Batteries does not currently support the ~with_positions:false
    mode available since OCaml 4.08 to disable position tracking. If you
    need this, please get in touch with the Batteries maintainers.</p>
</div>
</div>


<pre><span id="VALfrom_channel"><span class="keyword">val</span> from_channel</span> : <code class="type"><a href="BatIO.html#TYPEinput">BatIO.input</a> -> <a href="BatLexing.html#TYPElexbuf">lexbuf</a></code></pre><div class="info ">
<div class="info-desc">
<p>Create a lexer buffer on the given input channel.
   <code class="code"><span class="constructor">Lexing</span>.from_channel&nbsp;inchan</code> returns a lexer buffer which reads
   from the input channel <code class="code">inchan</code>, at the current reading position.</p>
</div>
</div>

<pre><span id="VALfrom_string"><span class="keyword">val</span> from_string</span> : <code class="type">?with_positions:bool -> string -> <a href="BatLexing.html#TYPElexbuf">lexbuf</a></code></pre><div class="info ">
<div class="info-desc">
<p>Create a lexer buffer which reads from
   the given string. Reading starts from the first character in
   the string. An end-of-input condition is generated when the
   end of the string is reached.</p>
</div>
</div>

<pre><span id="VALfrom_function"><span class="keyword">val</span> from_function</span> : <code class="type">?with_positions:bool -> (bytes -> int -> int) -> <a href="BatLexing.html#TYPElexbuf">lexbuf</a></code></pre><div class="info ">
<div class="info-desc">
<p>Create a lexer buffer with the given function as its reading method.
   When the scanner needs more characters, it will call the given
   function, giving it a byte sequence <code class="code">s</code> and a byte
   count <code class="code">n</code>. The function should put <code class="code">n</code> bytes or fewer in <code class="code">s</code>,
   starting at index 0, and return the number of bytes
   provided. A return value of 0 means end of input.</p>
</div>
</div>

<pre><span id="VALwith_positions"><span class="keyword">val</span> with_positions</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Tell whether the lexer buffer keeps track of position fields
    <code class="code">lex_curr_p</code> / <code class="code">lex_start_p</code>, as determined by the corresponding
    optional argument for functions that create lexer buffers
    (whose default value is <code class="code"><span class="keyword">true</span></code>).</p>

<p>When <code class="code">with_positions</code> is <code class="code"><span class="keyword">false</span></code>, lexer actions should not
    modify position fields.  Doing it nevertheless could
    re-enable the <code class="code">with_position</code> mode and degrade performances.</p>
</div>
</div>
<h7 id="6_Functionsforlexersemanticactions">Functions for lexer semantic actions</h7><p>The following functions can be called from the semantic actions
    of lexer definitions (the ML code enclosed in braces that
    computes the value returned by lexing functions). They give
    access to the character string matched by the regular expression
    associated with the semantic action. These functions must be
    applied to the argument <code class="code">lexbuf</code>, which, in the code generated by
    <code class="code">ocamllex</code>, is bound to the lexer buffer passed to the parsing
    function.</p>

<pre><span id="VALlexeme"><span class="keyword">val</span> lexeme</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> string</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code"><span class="constructor">Lexing</span>.lexeme&nbsp;lexbuf</code> returns the string matched by
           the regular expression.</p>
</div>
</div>

<pre><span id="VALlexeme_char"><span class="keyword">val</span> lexeme_char</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> int -> char</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code"><span class="constructor">Lexing</span>.lexeme_char&nbsp;lexbuf&nbsp;i</code> returns character number <code class="code">i</code> in
    the matched string.</p>
</div>
</div>

<pre><span id="VALlexeme_start"><span class="keyword">val</span> lexeme_start</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code"><span class="constructor">Lexing</span>.lexeme_start&nbsp;lexbuf</code> returns the offset in the
    input stream of the first character of the matched string.
    The first character of the stream has offset 0.</p>
</div>
</div>

<pre><span id="VALlexeme_end"><span class="keyword">val</span> lexeme_end</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code"><span class="constructor">Lexing</span>.lexeme_end&nbsp;lexbuf</code> returns the offset in the input stream
    of the character following the last character of the matched
    string. The first character of the stream has offset 0.</p>
</div>
</div>

<pre><span id="VALlexeme_start_p"><span class="keyword">val</span> lexeme_start_p</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> <a href="BatLexing.html#TYPEposition">position</a></code></pre><div class="info ">
<div class="info-desc">
<p>Like <code class="code">lexeme_start</code>, but return a complete <code class="code">position</code> instead
    of an offset.</p>
</div>
</div>

<pre><span id="VALlexeme_end_p"><span class="keyword">val</span> lexeme_end_p</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> <a href="BatLexing.html#TYPEposition">position</a></code></pre><div class="info ">
<div class="info-desc">
<p>Like <code class="code">lexeme_end</code>, but return a complete <code class="code">position</code> instead
    of an offset.</p>
</div>
</div>

<pre><span id="VALnew_line"><span class="keyword">val</span> new_line</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Update the <code class="code">lex_curr_p</code> field of the lexbuf to reflect the start
    of a new line.  You can call this function in the semantic action
    of the rule that matches the end-of-line character.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 3.11.0</li>
</ul>
</div>
<h7 id="6_Miscellaneousfunctions">Miscellaneous functions</h7>
<pre><span id="VALflush_input"><span class="keyword">val</span> flush_input</span> : <code class="type"><a href="BatLexing.html#TYPElexbuf">lexbuf</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p>Discard the contents of the buffer and reset the current
    position to 0.  The next use of the lexbuf will trigger a
    refill.</p>
</div>
</div>
</body></html>
