<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="Start" href="index.html">
<link rel="previous" href="BatSet.Incubator.html">
<link rel="Up" href="BatSet.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of exceptions" rel=Appendix href="index_exceptions.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of class methods" rel=Appendix href="index_methods.html">
<link title="Index of classes" rel=Appendix href="index_classes.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="BatArray" rel="Chapter" href="BatArray.html">
<link title="BatAvlTree" rel="Chapter" href="BatAvlTree.html">
<link title="BatBase64" rel="Chapter" href="BatBase64.html">
<link title="BatBig_int" rel="Chapter" href="BatBig_int.html">
<link title="BatBigarray" rel="Chapter" href="BatBigarray.html">
<link title="BatBitSet" rel="Chapter" href="BatBitSet.html">
<link title="BatBool" rel="Chapter" href="BatBool.html">
<link title="BatBounded" rel="Chapter" href="BatBounded.html">
<link title="BatBuffer" rel="Chapter" href="BatBuffer.html">
<link title="BatBytes" rel="Chapter" href="BatBytes.html">
<link title="BatBytesCompat" rel="Chapter" href="BatBytesCompat.html">
<link title="BatCache" rel="Chapter" href="BatCache.html">
<link title="BatChar" rel="Chapter" href="BatChar.html">
<link title="BatCharParser" rel="Chapter" href="BatCharParser.html">
<link title="BatComplex" rel="Chapter" href="BatComplex.html">
<link title="BatConcreteQueue" rel="Chapter" href="BatConcreteQueue.html">
<link title="BatConcurrent" rel="Chapter" href="BatConcurrent.html">
<link title="BatDeque" rel="Chapter" href="BatDeque.html">
<link title="BatDigest" rel="Chapter" href="BatDigest.html">
<link title="BatDllist" rel="Chapter" href="BatDllist.html">
<link title="BatDynArray" rel="Chapter" href="BatDynArray.html">
<link title="BatEnum" rel="Chapter" href="BatEnum.html">
<link title="BatFile" rel="Chapter" href="BatFile.html">
<link title="BatFingerTree" rel="Chapter" href="BatFingerTree.html">
<link title="BatFloat" rel="Chapter" href="BatFloat.html">
<link title="BatFormat" rel="Chapter" href="BatFormat.html">
<link title="BatGc" rel="Chapter" href="BatGc.html">
<link title="BatGenlex" rel="Chapter" href="BatGenlex.html">
<link title="BatGlobal" rel="Chapter" href="BatGlobal.html">
<link title="BatHashcons" rel="Chapter" href="BatHashcons.html">
<link title="BatHashtbl" rel="Chapter" href="BatHashtbl.html">
<link title="BatHeap" rel="Chapter" href="BatHeap.html">
<link title="BatIMap" rel="Chapter" href="BatIMap.html">
<link title="BatIO" rel="Chapter" href="BatIO.html">
<link title="BatISet" rel="Chapter" href="BatISet.html">
<link title="BatInnerIO" rel="Chapter" href="BatInnerIO.html">
<link title="BatInnerPervasives" rel="Chapter" href="BatInnerPervasives.html">
<link title="BatInnerShuffle" rel="Chapter" href="BatInnerShuffle.html">
<link title="BatInnerWeaktbl" rel="Chapter" href="BatInnerWeaktbl.html">
<link title="BatInt" rel="Chapter" href="BatInt.html">
<link title="BatInt32" rel="Chapter" href="BatInt32.html">
<link title="BatInt64" rel="Chapter" href="BatInt64.html">
<link title="BatInterfaces" rel="Chapter" href="BatInterfaces.html">
<link title="BatLazyList" rel="Chapter" href="BatLazyList.html">
<link title="BatLexing" rel="Chapter" href="BatLexing.html">
<link title="BatList" rel="Chapter" href="BatList.html">
<link title="BatLog" rel="Chapter" href="BatLog.html">
<link title="BatLogger" rel="Chapter" href="BatLogger.html">
<link title="BatMap" rel="Chapter" href="BatMap.html">
<link title="BatMarshal" rel="Chapter" href="BatMarshal.html">
<link title="BatMultiMap" rel="Chapter" href="BatMultiMap.html">
<link title="BatMultiPMap" rel="Chapter" href="BatMultiPMap.html">
<link title="BatMutex" rel="Chapter" href="BatMutex.html">
<link title="BatNativeint" rel="Chapter" href="BatNativeint.html">
<link title="BatNum" rel="Chapter" href="BatNum.html">
<link title="BatNumber" rel="Chapter" href="BatNumber.html">
<link title="BatOo" rel="Chapter" href="BatOo.html">
<link title="BatOpaqueInnerSys" rel="Chapter" href="BatOpaqueInnerSys.html">
<link title="BatOptParse" rel="Chapter" href="BatOptParse.html">
<link title="BatOption" rel="Chapter" href="BatOption.html">
<link title="BatOrd" rel="Chapter" href="BatOrd.html">
<link title="BatParserCo" rel="Chapter" href="BatParserCo.html">
<link title="BatPathGen" rel="Chapter" href="BatPathGen.html">
<link title="BatPervasives" rel="Chapter" href="BatPervasives.html">
<link title="BatPrintexc" rel="Chapter" href="BatPrintexc.html">
<link title="BatPrintf" rel="Chapter" href="BatPrintf.html">
<link title="BatQueue" rel="Chapter" href="BatQueue.html">
<link title="BatRMutex" rel="Chapter" href="BatRMutex.html">
<link title="BatRandom" rel="Chapter" href="BatRandom.html">
<link title="BatRef" rel="Chapter" href="BatRef.html">
<link title="BatRefList" rel="Chapter" href="BatRefList.html">
<link title="BatResult" rel="Chapter" href="BatResult.html">
<link title="BatReturn" rel="Chapter" href="BatReturn.html">
<link title="BatScanf" rel="Chapter" href="BatScanf.html">
<link title="BatSeq" rel="Chapter" href="BatSeq.html">
<link title="BatSet" rel="Chapter" href="BatSet.html">
<link title="BatSplay" rel="Chapter" href="BatSplay.html">
<link title="BatStack" rel="Chapter" href="BatStack.html">
<link title="BatStream" rel="Chapter" href="BatStream.html">
<link title="BatString" rel="Chapter" href="BatString.html">
<link title="BatSubstring" rel="Chapter" href="BatSubstring.html">
<link title="BatSys" rel="Chapter" href="BatSys.html">
<link title="BatText" rel="Chapter" href="BatText.html">
<link title="BatTuple" rel="Chapter" href="BatTuple.html">
<link title="BatUChar" rel="Chapter" href="BatUChar.html">
<link title="BatUTF8" rel="Chapter" href="BatUTF8.html">
<link title="BatUnit" rel="Chapter" href="BatUnit.html">
<link title="BatUnix" rel="Chapter" href="BatUnix.html">
<link title="BatUref" rel="Chapter" href="BatUref.html">
<link title="BatVect" rel="Chapter" href="BatVect.html">
<link title="Batteries" rel="Chapter" href="Batteries.html">
<link title="BatteriesConfig" rel="Chapter" href="BatteriesConfig.html">
<link title="BatteriesExceptionless" rel="Chapter" href="BatteriesExceptionless.html">
<link title="BatteriesPrint" rel="Chapter" href="BatteriesPrint.html">
<link title="BatteriesThread" rel="Chapter" href="BatteriesThread.html">
<link title="Extlib" rel="Chapter" href="Extlib.html"><link title="Polymorphic sets" rel="Section" href="#6_Polymorphicsets">
<link title="Boilerplate code" rel="Section" href="#6_Boilerplatecode">
<link title="Printing" rel="Subsection" href="#7_Printing">
<link title="Infix operators" rel="Subsection" href="#7_Infixoperators">
<title>Batteries user guide : BatSet.PSet</title>
</head>
<body>
<div class="navbar"><a class="pre" href="BatSet.Incubator.html" title="BatSet.Incubator">Previous</a>
&nbsp;<a class="up" href="BatSet.html" title="BatSet">Up</a>
&nbsp;</div>
<h1>Module <a href="type_BatSet.PSet.html">BatSet.PSet</a></h1>

<pre><span id="MODULEPSet"><span class="keyword">module</span> PSet</span>: <code class="code"><span class="keyword">sig</span></code> <a href="BatSet.PSet.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><hr width="100%">
<h7 id="6_Polymorphicsets">Polymorphic sets</h7>
<p>The definitions below describe the polymorphic set interface.</p>

<p>They are similar in functionality to the functorized
      <a href="BatSet.Make.html"><code class="code"><span class="constructor">BatSet</span>.<span class="constructor">Make</span></code></a> module, but the compiler cannot ensure that sets
      using different element ordering have different types: the
      responsibility of not mixing non-sensical comparison functions
      together is to the programmer. If you ever need a custom
      comparison function, it is recommended to use the <a href="BatSet.Make.html"><code class="code"><span class="constructor">BatSet</span>.<span class="constructor">Make</span></code></a>
      functor for additional safety.</p>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type">'a</code> t</span> </pre>
<div class="info ">
<div class="info-desc">
<p>The type of sets.</p>
</div>
</div>


<pre><span class="keyword">include</span> <a href="BatEnum.Enumerable.html">BatEnum.Enumerable</a></pre>

<pre><span class="keyword">include</span> <a href="BatInterfaces.Mappable.html">BatInterfaces.Mappable</a></pre>

<pre><span id="VALempty"><span class="keyword">val</span> empty</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>The empty set, using <code class="code">compare</code> as comparison function</p>
</div>
</div>

<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">('a -> 'a -> int) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Creates a new empty set, using the provided function for key comparison.</p>
</div>
</div>

<pre><span id="VALis_empty"><span class="keyword">val</span> is_empty</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Test whether a set is empty or not.</p>
</div>
</div>

<pre><span id="VALsingleton"><span class="keyword">val</span> singleton</span> : <code class="type">?cmp:('a -> 'a -> int) -> 'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Creates a new set with the single given element in it.</p>
</div>
</div>

<pre><span id="VALmem"><span class="keyword">val</span> mem</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">mem&nbsp;x&nbsp;s</code> tests whether <code class="code">x</code> belongs to the set <code class="code">s</code>.</p>
</div>
</div>

<pre><span id="VALfind"><span class="keyword">val</span> find</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">find&nbsp;x&nbsp;s</code> returns the element in s that tests equal to <code class="code">x</code> under its comparison function.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Not_found</code> if no element is equal</li>
</ul>
</div>

<pre><span id="VALadd"><span class="keyword">val</span> add</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">add&nbsp;x&nbsp;s</code> returns a set containing all elements of <code class="code">s</code>,
      plus <code class="code">x</code>. If <code class="code">x</code> was already in <code class="code">s</code>, <code class="code">s</code> is returned unchanged.</p>
</div>
</div>

<pre><span id="VALremove"><span class="keyword">val</span> remove</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">remove&nbsp;x&nbsp;s</code> returns a set containing all elements of <code class="code">s</code>,
      except <code class="code">x</code>. If <code class="code">x</code> was not in <code class="code">s</code>, <code class="code">s</code> is returned unchanged.</p>
</div>
</div>

<pre><span id="VALupdate"><span class="keyword">val</span> update</span> : <code class="type">'a -> 'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">update&nbsp;x&nbsp;y&nbsp;s</code> replace <code class="code">x</code> by <code class="code">y</code> in <code class="code">s</code>.
      <code class="code">update</code> is faster when <code class="code">x</code> compares equal to <code class="code">y</code> according
      to the comparison function used by your set.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 2.4</li>
<li><b>Raises</b> <code>Not_found</code> if <code class="code">x</code> is not in <code class="code">s</code>.</li>
</ul>
</div>

<pre><span id="VALunion"><span class="keyword">val</span> union</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">union&nbsp;s&nbsp;t</code> returns the union of <code class="code">s</code> and <code class="code">t</code> - the set containing
      all elements in either <code class="code">s</code> and <code class="code">t</code>.  The returned set uses <code class="code">t</code>'s
      comparison function.  The current implementation works better for
      small <code class="code">s</code>.</p>
</div>
</div>

<pre><span id="VALintersect"><span class="keyword">val</span> intersect</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">intersect&nbsp;s&nbsp;t</code> returns a new set of those elements that are in
      both <code class="code">s</code> and <code class="code">t</code>.  The returned set uses <code class="code">s</code>'s comparison function.</p>
</div>
</div>

<pre><span id="VALdiff"><span class="keyword">val</span> diff</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">diff&nbsp;s&nbsp;t</code> returns the set of all elements in <code class="code">s</code> but not in
      <code class="code">t</code>. The returned set uses <code class="code">s</code>'s comparison function.</p>
</div>
</div>

<pre><span id="VALsym_diff"><span class="keyword">val</span> sym_diff</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">sym_diff&nbsp;s&nbsp;t</code> returns the set of all elements in <code class="code">s</code> or <code class="code">t</code> but not both.
      This is the same as <code class="code">diff&nbsp;(union&nbsp;s&nbsp;t)&nbsp;(inter&nbsp;s&nbsp;t)</code>. The returned set uses
      <code class="code">s</code>'s comparison function.</p>
</div>
</div>

<pre><span id="VALcompare"><span class="keyword">val</span> compare</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Total ordering between sets. Can be used as the ordering function
      for doing sets of sets.</p>
</div>
</div>

<pre><span id="VALequal"><span class="keyword">val</span> equal</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">equal&nbsp;s1&nbsp;s2</code> tests whether the sets <code class="code">s1</code> and <code class="code">s2</code> are
      equal, that is, contain equal elements.</p>
</div>
</div>

<pre><span id="VALsubset"><span class="keyword">val</span> subset</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">subset&nbsp;a&nbsp;b</code> returns true if <code class="code">a</code> is a subset of <code class="code">b</code>. O(|a|).</p>
</div>
</div>

<pre><span id="VALdisjoint"><span class="keyword">val</span> disjoint</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">disjoint&nbsp;s1&nbsp;s2</code> tests whether the sets <code class="code">s1</code> and <code class="code">s2</code> contain no
      shared elements. (i.e. <code class="code">inter&nbsp;s1&nbsp;s2</code> is empty.)</p>
</div>
</div>

<pre><span id="VALiter"><span class="keyword">val</span> iter</span> : <code class="type">('a -> unit) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> unit</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">iter&nbsp;f&nbsp;s</code> applies <code class="code">f</code> in turn to all elements of <code class="code">s</code>.
      The elements of <code class="code">s</code> are presented to <code class="code">f</code> in increasing order
      with respect to the ordering over the type of the elements.</p>
</div>
</div>

<pre><span id="VALat_rank_exn"><span class="keyword">val</span> at_rank_exn</span> : <code class="type">int -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">at_rank_exn&nbsp;i&nbsp;s</code> returns element at rank <code class="code">i</code> in <code class="code">s</code>, that is
      the <code class="code">i</code>-th element in increasing order
      (the <code class="code">0</code>-th element being the smallest element of <code class="code">s</code>).</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 2.4</li>
<li><b>Raises</b><ul><li><code>Not_found</code> if <code class="code">s&nbsp;=&nbsp;empty</code>.</li>
<li><code>Invalid_argument</code> error_message if <code class="code">i&nbsp;&lt;&nbsp;0&nbsp;<span class="keywordsign">||</span>&nbsp;i&nbsp;&gt;=&nbsp;cardinal&nbsp;s</code></li>
</ul></li>
</ul>
</div>

<pre><span id="VALmap"><span class="keyword">val</span> map</span> : <code class="type">('a -> 'b) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'b <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">map&nbsp;f&nbsp;x</code> creates a new set with elements <code class="code">f&nbsp;a0</code>,
      <code class="code">f&nbsp;a1</code>... <code class="code">f&nbsp;aN</code>, where <code class="code">a0</code>, <code class="code">a1</code>, ..., <code class="code">aN</code> are the
      values contained in <code class="code">x</code></p>

<p>The resulting map uses the polymorphic <code class="code">compare</code> function to
      order elements.</p>
</div>
</div>

<pre><span id="VALfilter"><span class="keyword">val</span> filter</span> : <code class="type">('a -> bool) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">filter&nbsp;p&nbsp;s</code> returns the set of all elements in <code class="code">s</code>
      that satisfy predicate <code class="code">p</code>.</p>
</div>
</div>

<pre><span id="VALfilter_map"><span class="keyword">val</span> filter_map</span> : <code class="type">('a -> 'b option) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'b <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">filter_map&nbsp;f&nbsp;m</code> combines the features of <code class="code">filter</code> and
      <code class="code">map</code>.  It calls calls <code class="code">f&nbsp;a0</code>, <code class="code">f&nbsp;a1</code>, <code class="code">f&nbsp;aN</code> where <code class="code">a0,a1..an</code>
      are the elements of <code class="code">m</code> and returns the set of pairs <code class="code">bi</code>
      such as <code class="code">f&nbsp;ai&nbsp;=&nbsp;<span class="constructor">Some</span>&nbsp;bi</code> (when <code class="code">f</code> returns <code class="code"><span class="constructor">None</span></code>, the
      corresponding element of <code class="code">m</code> is discarded).</p>

<p>The resulting map uses the polymorphic <code class="code">compare</code> function to
      order elements.</p>
</div>
</div>

<pre><span id="VALfold"><span class="keyword">val</span> fold</span> : <code class="type">('a -> 'b -> 'b) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'b -> 'b</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">fold&nbsp;f&nbsp;s&nbsp;a</code> computes <code class="code">(f&nbsp;xN&nbsp;...&nbsp;(f&nbsp;x1&nbsp;(f&nbsp;x0&nbsp;a))...)</code>,
      where <code class="code">x0,x1..xN</code> are the elements of <code class="code">s</code>, in increasing order.</p>
</div>
</div>

<pre><span id="VALexists"><span class="keyword">val</span> exists</span> : <code class="type">('a -> bool) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">exists&nbsp;p&nbsp;s</code> checks if at least one element of
      the set satisfies the predicate <code class="code">p</code>.</p>
</div>
</div>

<pre><span id="VALfor_all"><span class="keyword">val</span> for_all</span> : <code class="type">('a -> bool) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> bool</code></pre><div class="info ">
<div class="info-desc">
<p>Returns whether the given predicate applies to all elements in the set</p>
</div>
</div>

<pre><span id="VALpartition"><span class="keyword">val</span> partition</span> : <code class="type">('a -> bool) -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>returns two disjoint subsets, those that satisfy the given
      predicate and those that don't</p>
</div>
</div>

<pre><span id="VALsplit"><span class="keyword">val</span> split</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> * bool * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">split&nbsp;x&nbsp;s</code> returns a triple <code class="code">(l,&nbsp;present,&nbsp;r)</code>, where
      <code class="code">l</code> is the set of elements of <code class="code">s</code> that are
      strictly less than <code class="code">x</code>;
      <code class="code">r</code> is the set of elements of <code class="code">s</code> that are
      strictly greater than <code class="code">x</code>;
      <code class="code">present</code> is <code class="code"><span class="keyword">false</span></code> if <code class="code">s</code> contains no element equal to <code class="code">x</code>,
      or <code class="code"><span class="keyword">true</span></code> if <code class="code">s</code> contains an element equal to <code class="code">x</code>.</p>
</div>
</div>

<pre><span id="VALsplit_opt"><span class="keyword">val</span> split_opt</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> * 'a option * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">split_opt&nbsp;x&nbsp;s</code> returns a triple <code class="code">(l,&nbsp;maybe_v,&nbsp;r)</code>, where
        <code class="code">l</code> is the set of elements of <code class="code">s</code> that are
        strictly less than <code class="code">x</code>;
        <code class="code">r</code> is the set of elements of <code class="code">s</code> that are
        strictly greater than <code class="code">x</code>;
        <code class="code">maybe_v</code> is <code class="code"><span class="constructor">None</span></code> if <code class="code">s</code> contains no element equal to <code class="code">x</code>,
        or <code class="code"><span class="constructor">Some</span>&nbsp;v</code> if <code class="code">s</code> contains an element <code class="code">v</code> that compares equal to <code class="code">x</code>.</p>
</div>
</div>

<pre><span id="VALsplit_lt"><span class="keyword">val</span> split_lt</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">split_lt&nbsp;x&nbsp;s</code> returns a pair of sets <code class="code">(l,&nbsp;r)</code>, such that
      <code class="code">l</code> is the subset of <code class="code">s</code> with elements &lt; <code class="code">x</code>;
      <code class="code">r</code> is the subset of <code class="code">s</code> with elements &gt;= <code class="code">x</code>.</p>
</div>
</div>

<pre><span id="VALsplit_le"><span class="keyword">val</span> split_le</span> : <code class="type">'a -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a> * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p><code class="code">split_le&nbsp;x&nbsp;s</code> returns a pair of sets <code class="code">(l,&nbsp;r)</code>, such that
      <code class="code">l</code> is the subset of <code class="code">s</code> with elements &lt;= <code class="code">x</code>;
      <code class="code">r</code> is the subset of <code class="code">s</code> with elements &gt; <code class="code">x</code>.</p>
</div>
</div>

<pre><span id="VALcardinal"><span class="keyword">val</span> cardinal</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> int</code></pre><div class="info ">
<div class="info-desc">
<p>Return the number of elements of a set.</p>
</div>
</div>

<pre><span id="VALelements"><span class="keyword">val</span> elements</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a list</code></pre><div class="info ">
<div class="info-desc">
<p>Return the list of all elements of the given set.
      The returned list is sorted in increasing order with respect
      to the ordering of the given set.</p>
</div>
</div>

<pre><span id="VALto_list"><span class="keyword">val</span> to_list</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a list</code></pre><div class="info ">
<div class="info-desc">
<p>Alias for <code class="code">elements</code>.</p>
</div>
</div>

<pre><span id="VALto_array"><span class="keyword">val</span> to_array</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a array</code></pre><div class="info ">
<div class="info-desc">
<p>Same as <code class="code">to_list</code> but with an array instead of a list.</p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 2.4</li>
</ul>
</div>

<pre><span id="VALmin_elt"><span class="keyword">val</span> min_elt</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>returns the smallest element of the set.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Not_found</code> if given an empty set.</li>
</ul>
</div>

<pre><span id="VALpop_min"><span class="keyword">val</span> pop_min</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Returns the smallest element of the given set
      along with the rest of the set.
      Semantically equivalent and faster than</p>

<p><code class="code"><span class="keyword">let</span>&nbsp;mini&nbsp;=&nbsp;min_elt&nbsp;s&nbsp;<span class="keyword">in</span>&nbsp;(mini,&nbsp;remove&nbsp;mini&nbsp;s)</code></p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 2.4</li>
<li><b>Raises</b> <code>Not_found</code> if the set is empty.</li>
</ul>
</div>

<pre><span id="VALpop_max"><span class="keyword">val</span> pop_max</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Returns the biggest element of the given set
      along with the rest of the set.
      Semantically equivalent and faster than</p>

<p><code class="code"><span class="keyword">let</span>&nbsp;maxi&nbsp;=&nbsp;max_elt&nbsp;s&nbsp;<span class="keyword">in</span>&nbsp;(maxi,&nbsp;remove&nbsp;maxi&nbsp;s)</code></p>
</div>
<ul class="info-attributes">
<li><b>Since</b> 2.4</li>
<li><b>Raises</b> <code>Not_found</code> if the set is empty.</li>
</ul>
</div>

<pre><span id="VALmax_elt"><span class="keyword">val</span> max_elt</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>returns the largest element of the set.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Not_found</code> if given an empty set.</li>
</ul>
</div>

<pre><span id="VALchoose"><span class="keyword">val</span> choose</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>returns an arbitrary (but deterministic) element of the given set.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Not_found</code> if given an empty set.</li>
</ul>
</div>

<pre><span id="VALany"><span class="keyword">val</span> any</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a</code></pre><div class="info ">
<div class="info-desc">
<p>Return one element of the given set.
      The difference with choose is that there is no guarantee that equals
      elements will be picked for equal sets.
      This merely returns the quickest element to get (O(1)).</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Not_found</code> if the set is empty.</li>
</ul>
</div>

<pre><span id="VALpop"><span class="keyword">val</span> pop</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a * 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>returns one element of the set and the set without that element.</p>
</div>
<ul class="info-attributes">
<li><b>Raises</b> <code>Not_found</code> if given an empty set</li>
</ul>
</div>

<pre><span id="VALenum"><span class="keyword">val</span> enum</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a></code></pre><div class="info ">
<div class="info-desc">
<p>Return an enumeration of all elements of the given set.
      The returned enumeration is sorted in increasing order with respect
      to the ordering of this set.</p>
</div>
</div>

<pre><span id="VALof_enum"><span class="keyword">val</span> of_enum</span> : <code class="type">'a <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_enum_cmp"><span class="keyword">val</span> of_enum_cmp</span> : <code class="type">cmp:('a -> 'a -> int) -> 'a <a href="BatEnum.html#TYPEt">BatEnum.t</a> -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre>
<pre><span id="VALof_list"><span class="keyword">val</span> of_list</span> : <code class="type">'a list -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>builds a set from the given list, using the default comparison
      function</p>
</div>
</div>

<pre><span id="VALof_array"><span class="keyword">val</span> of_array</span> : <code class="type">'a array -> 'a <a href="BatSet.PSet.html#TYPEt">t</a></code></pre><div class="info ">
<div class="info-desc">
<p>builds a set from the given array, using the default comparison
      function</p>
</div>
</div>
<h7 id="6_Boilerplatecode">Boilerplate code</h7><div class="h8" id="7_Printing">Printing</div>
<pre><span id="VALprint"><span class="keyword">val</span> print</span> : <code class="type">?first:string -><br>       ?last:string -><br>       ?sep:string -><br>       ('a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'c -> unit) -><br>       'a <a href="BatInnerIO.html#TYPEoutput">BatInnerIO.output</a> -> 'c <a href="BatSet.PSet.html#TYPEt">t</a> -> unit</code></pre><div class="h8" id="7_Infixoperators">Infix operators</div>
<pre><span id="MODULEInfix"><span class="keyword">module</span> <a href="BatSet.PSet.Infix.html">Infix</a></span>: <code class="code"><span class="keyword">sig</span></code> <a href="BatSet.PSet.Infix.html">..</a> <code class="code"><span class="keyword">end</span></code></pre>
<pre><span id="VALget_cmp"><span class="keyword">val</span> get_cmp</span> : <code class="type">'a <a href="BatSet.PSet.html#TYPEt">t</a> -> 'a -> 'a -> int</code></pre><div class="info ">
<div class="info-desc">
<p>get the comparison function used for a polymorphic map</p>
</div>
</div>
</body></html>